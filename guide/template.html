<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title>mx3</title>
	<style media="all" type="text/css">
		body { margin: 20px; font-family: Ubuntu, Arial, sans-serif; font-size: 14px; }
		h1   { font-size: 22px; font-weight: normal; color: #000088}
		h2   { font-size: 18px; font-weight: normal; color: #000088}
		h3   { font-size: 15px; font-weight: normal; color: #000088}
		table{ border:"10"; }
		hr   { border-style: none; border-top: 1px solid #CCCCCC; margin-top: 20px; margin-bottom: 20px }
		a    { color: #375EAB; text-decoration: none; }
		div  { margin-left: 20px; margin-top: 10px; margin-bottom: 20px; }
		pre  { margin-left: 50px; margin-top: 10px; margin-bottom: 20px; color: #000044 }
	</style>
</head>

<body>

<h1>mx3 Examples</h1>
<hr/>

mx3 input files are run with the command
<pre>mx3 myfile.txt</pre>
Output is automatically stored in the "myfile.out" directory. Additionally, a web interface provides live output. Default is localhost:35367.<br/>
For more details refer to the <a href="http://godoc.org/code.google.com/p/mx3">godoc documentation</a>.

<hr/><h2>A first example</h2>

Let's start with the classic mumag standard problem 4, as defined <a href="http://www.ctcms.nist.gov/~rdm/mumag.org.html">here</a>.

{{.Example `

SetGridsize(128, 32, 1)
SetCellsize(500e-9/128, 125e-9/32, 3e-9)

alpha = 1
Msat  = 800e3
Aex   = 13e-12
m     = uniform(1, .1, 0) // initial m

run(3e-9)  // relax
save(m)    // relaxed state

Autosave(m, 200e-12)
alpha = 0.02
B_ext = vector(-24.6E-3, 4.3E-3, 0)
run(1e-9)

`}}

This example should be pretty straight-forward to follow. Output is stored in the efficient ".dump" format, which can be converted with <a href=http://godoc.org/code.google.com/p/mx3/tools/mx3-convert>mx3-convert</a>. Below is the output converted to PNG.

{{.Output }}

<hr/><h2>Material parameters</h2>

Overview of the available material parameters:

{{.Example `
Msat  = 1000e3    // Saturation magnetization in A/m
Aex   = 13e-12    // Exchange stiffness in J/m
alpha = 0.02      // Gilbert damping constant

anisU = vector(1, 0, 0) // Uniaxial anisotropy axis
Ku1   = 500e3           // Uniaxial anisotropy in J/m3

xi      = 0.04    // Spin-transfer torque degree of non-adiabaticity
spinPol = 0.56    // Spin polarization

DMI = 1e-3        // Dzyaloshinskii-Moriya interaction in J/m2
`}}

This input file does not create any output.

<hr/><h2>Interlude on Syntax</h2>

<p>
Before we continue we might have a look at the mx3 input syntax. It is a subset of <a href=http://golang.org>Go</a>'s syntax, somewhat similar to C. It is case-independent however, so msat is the same as Msat or MSAT.</p>

<h3>Defining variables</h3>
{{.Example `
i := 7    // defines a new variable i, type automatically detected to be int
print(i)  // now we can use i
i = 5     // assign new value, don't use ':=' (attempt to re-declare)

str := "hello" // defines str, type automatically is string
//str = 1      // would fail, cannot assign int to string
`}}

<h3>Arithmetic</h3>
Most common arithmetic operations are possible. Also Go's <a href=http://golang.org/pkg/math>math</a> library and some common constants are available. For raise-to-the-power, pow(x,y) should be used.

{{.Example `
x := pi*(3+4)/5
x = pow(x, 3)
x++
y := abs(cbrt(cosh(erf(erfc(gamma(J0(Y0(2))))))))
`}}

<h3>Control structures</h3>
Loops are possible as well:
{{.Example `

for i:=0; i<10; i++{
	print(i)
}

`}}

<hr/><h2>Standard problem 2</h2>

Using the scripting language explained above, relatively complex input files can be easily defined. E.g. <a href="http://www.ctcms.nist.gov/~rdm/std2/spec2.html">micromagnetic standard problem #2</a> specifies the simulation size in exchange lengths. The script below calculates the exchange length and chooses cells not larger than 0.75 exchange lengths so that the number of cells is a power of two (for best performance).


{{.Example  `
Msat  = 1000e3
Aex   = 10e-12
alpha = 3

// define exchange length
lex := sqrt(Aex / (0.5 * mu0 * pow(Msat.GetUniform(),2)))

d     := 30 * lex                        // we test for d/lex = 30
Sizex := 5*d                             // magnet size x
Sizey := 1*d
Sizez := 0.1*d

nx := pow(2, ilogb(Sizex / (0.75*lex)))  // power-of-two number of cells
ny := pow(2, ilogb(Sizey / (0.75*lex)))  // not larger than 0.75 exchange lengths

SetGridSize(nx, ny, 1)
SetCellSize(Sizex/nx, Sizey/ny, Sizez)

m = Uniform(1, 0.1, 0)                   // initial mag
Run(5e-9)                                // relax

save(m)                                  // remanent magnetization
m_ := average(m)                         
expect("mx", m_[0], 0.9627, 1e-3)        // test m against known value
expect("my", m_[1], 0.0756, 1e-3)
expect("mz", m_[2], 0, 1e-3)
`}}

{{.Output}}

This example saves the remanent magnetization state, and verifies the average magnetization has the correct value.

<hr/><h2>Geometry</h2>

mx3 has powerful API to programatically define geometries. A number of primitive shapes are defined, like ellipses, rectangles, etc. They can be transformed (rotated, translated) and combined using boolean logic (add, sub, inverse). See the full <a href="http://godoc.org/code.google.com/p/mx3/engine#Shape">API</a>.


{{.Example `
setgridsize(100, 100, 50)
setcellsize(1e-6/100, 1e-6/100, 1e-6/50)

setgeom(rect(800e-9, 500e-9))
m=uniform(1,1,0)
saveas(m, "rect")

setgeom(rect(800e-9, 500e-9).rotz(30*pi/180))
m=uniform(1,1,0)
saveas(m, "rect_rotz")

setgeom(cylinder(800e-9, 600e-9))
m=uniform(1,1,0)
saveas(m, "cylinder")

setgeom(cylinder(800e-9, 600e-9).inverse())
m=uniform(1,1,0)
saveas(m, "cylinder_inverse")

setgeom(cylinder(800e-9, 600e-9).transl(200e-9, 100e-9, 0))
m=uniform(1,1,0)
saveas(m, "cylinder_transl")

setgeom(ellipsoid(800e-9, 600e-9, 500e-9))
m=uniform(1,1,0)
saveas(m, "ellipsoid")

setgeom(halfspace())
m=uniform(1,1,0)
saveas(m, "halfspace")

setgeom(rect(800e-9, 500e-9).sub(halfspace().rotz(30*pi/180)))
m=uniform(1,1,0)
saveas(m, "rect_sub_haflspace_rotz")

`}}

{{.Output}}

Note: these are 3D geometries seen from above. The magnetization is averaged along the thickness. Also, when setting a geometry, the magnetization outside the geometry is removed (set to zero). So each time we set a new geometry we have re-initialized m.
<hr/><h2>Interlude: rotating cheese</h2>

In this example we define a geometry that looks like a slice of cheese and have it rotate in time.

{{.Example `

setgridsize(128, 128, 1)
setcellsize(2e-9, 2e-9, 2e-9)

d      := 200e-9
square := rect(d, d)                 // square with side d

h     := 50e-9
hole  := cylinder(h, h)              // circle with diameter h
hole1 := hole.transl(100e-9, 0, 0)   // translated circle #1
hole2 := hole.transl(0, -50e-9, 0)   // translated cricle #2
cheese:= square.sub(hole1).sub(hole2)// subtract the circles form the square (makes holes).
setgeom(cheese)

msat = 600e3
aex = 12e-13
alpha = 3

// rotate the cheese.
for i:=0; i<=90; i=i+30{
	angle := i*pi/180
	setgeom(cheese.rotz(angle))
	m = uniform(cos(angle), sin(angle), 0)
	run(1e-9)
	save(m)
}

`}}

{{.Output}}


<hr/><h2>Regions: space-dependent parameters</h2>

<p>Space-dependent parameters are defined using material <i>regions</i>. Regions are numbered 0-255 and represent different materials. Region 0 conventionally everything outside your magnet (the vacuum), so setting material parameters starts at 1.</p>

<p>Regions are defined with <code>defregion(number, shape)</code>, where <code>shape</code> is a <a href="http://godoc.org/code.google.com/p/mx3/engine#Shape">Shape</a> as explained in the geometry example.</p>

<p>When you're not using regions, like in the above examples, you'll probably set parameters with a simple assign:
<pre>Aex = 12e-13</pre>
Behind the screens, this sets Aex in <i>all</i> regions.
</p>

<p>It's always a good idea to output the <code>regions</code> quantity, as well as all your material parameters, to check </p>

{{.Example `
N := 128
setgridsize(N, N, 1)
setcellsize(1e-9, 1e-9, 1e-9)
d := 1e-9 * N  

defregion(0, cylinder(d, d).inverse()) // everything outside is vacuum
defregion(1, cylinder(d, d))
defregion(2, cylinder(d/2, d/2))
defregion(3, cylinder(d/2, d/2).transl(d/3, 0, 0))
save(regions)

Ku1.setregion(1, 500)
Ku1.setregion(2, 0)
Ku1.setregion(3, -500)
save(Ku1)

Msat = 800e-3 // sets it everywhere
Msat.setregion(2, 500e3)
save(Msat)

m = uniform(1, 0, 0)
save(m)
`}}

{{.Output}}


<hr/><h2>Initial magnetization</h2>
Some initial magnetization functions are provided, as well as transformations on them. See the <a href="http://godoc.org/code.google.com/p/mx3/engine#Config">API</a>.

{{.Example `
setgridsize(200, 100, 1)
setcellsize(5e-9, 5e-9, 5e-9)

m = uniform(1, 1, 0)  // no need to normalize length
saveas(m, "uniform")

m = vortex(1, -1)     // circulation, polarization
saveas(m, "vortex")

m = twodomain(1,0,0,  0,1,0,  -1,0,0) // NÃ©el wall
saveas(m, "twodomain")

m = vortexwall(1, -1, 1, 1) 
saveas(m, "vortexwall")

m = vortex(1,-1).transl(100e-9, 50e-9, 0)
saveas(m, "vortex_transl")

`}}
{{.Output}}

These initial states are approximate, after setting them it is a good idea to relax the magnetization to the actual ground state.
</body>
</html>

